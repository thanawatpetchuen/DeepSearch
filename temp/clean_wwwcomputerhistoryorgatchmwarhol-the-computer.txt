



    	   The APL Programming Language Source Code | Computer History Museum
    













		#fancybox-close{right:-15px;top:-15px}
		div#fancybox-content{border-color:#FFFFFF}
		div#fancybox-title{background-color:#FFFFFF}
		div#fancybox-outer{background-color:#FFFFFF}
		div#fancybox-title-inside{color:#333333}
	






















jQuery(function(){

jQuery.fn.getTitle = function() { // Copy the title of every IMG tag and add it to its parent A so that fancybox can show titles
	var arr = jQuery("a.fancybox");
	jQuery.each(arr, function() {
		var title = jQuery(this).children("img").attr("title");
		jQuery(this).attr('title',title);
	})
}

// Supported file extensions
var thumbnails = jQuery("a:has(img)").not(".nolightbox").filter( function() { return /\.(jpe?g|png|gif|bmp)$/i.test(jQuery(this).attr('href')) });

thumbnails.addClass("fancybox").attr("rel","fancybox").getTitle();
jQuery("a.fancybox").fancybox({
	'cyclic': false,
	'autoScale': true,
	'padding': 10,
	'opacity': true,
	'speedIn': 500,
	'speedOut': 500,
	'changeSpeed': 300,
	'overlayShow': true,
	'overlayOpacity': "0.3",
	'overlayColor': "#666666",
	'titleShow': true,
	'titlePosition': 'inside',
	'enableEscapeButton': true,
	'showCloseButton': true,
	'showNavArrows': true,
	'hideOnOverlayClick': true,
	'hideOnContentClick': false,
	'width': 560,
	'height': 340,
	'transitionIn': "fade",
	'transitionOut': "fade",
	'centerOnScroll': true
});


})



















Get Involved
Contact
Directions
About Us

Donate Now














@chm
Museum Blog 




Centers
MuseumCenters




Collections
Discover the Museum's Offerings




Education
RevolutionizingLearning




Events
Experience theWorld of Computing




Exhibits
Learn about the People and Stories




Visit Us
Hours and Admission















                    117226                

                    Like Us
                








                    30070                

                    Follow Us
                








                    63614                

                    Watch Us
                








                    3703                

                    Follow Us
                
















Popular
Recent
Comments
Tags











The APL Programming Language Source Code
October 10, 2012
 13











Apple II DOS Source Code
November 12, 2013
 7











Microsoft Word for Windows Version 1.1a Source Code
March 25, 2014
 7











Make Software, Change the World!
October 05, 2012
 5











The Middleton Family at the New York World’s Fair, 1939
March 13, 2013
 3













2018 CHM Fellow Awards
1 day ago
 0











Building the Cathedral of Technology: The Fellow Awards at the Computer History Museum
6 days ago
 0











2018 Museum Fellow Dov Frohman-Bentchkowsky: Silicon, Science, Memory & Survival
2 weeks ago
 0











2018 Museum Fellow Dame Stephanie Shirley
3 weeks ago
 0











2018 Museum Fellow Guido van Rossum, Python Creator & Benevolent Dictator for Life
4 weeks ago
 0













                                    	Olaf Barthel                                        on
Electronic Arts DeluxePaint Early Source Code


										I learned 'C' in 1987/1988 on the Amiga, using a 1983 translation of the 19 [...]                                    










                                    	Matt Spergel                                        on
The Homebrew Computer Club 2013 Reunion


										If you're interested in learning about the real story behind this historic  [...]                                    










                                    	Alexander G. Riccio                                        on
Electronic Arts DeluxePaint Early Source Code


										Is that really what first-edition-C looked like? I'm sure glad it's changed [...]                                    










                                    	Prasenjit Singh Bist                                        on
MacPaint and QuickDraw Source Code


										Well I am a developer too and i respect and understand the joy and exciteme [...]                                    










                                    	HugoDanner                                        on
Electronic Arts DeluxePaint Early Source Code


										I still miss Dpaint for animation. To bad EA doesn't have the sense to upda [...]                                    





Anniversary
Apple
Apple Computer
Archives
Arpanet
artificial intelligence
Center for Software History
CHM
CHM Live
Cisco
collection
Computer Games
Computer History Museum
computing
DEC
education
ENIAC
Entrepreneurship
Exhibits
Exponential Center
Fairchild
Fairchild Semiconductor
Fellow Awards
Google
Gordon Moore
history
IBM
Intel
internet
iPhone
iPhone 360
John Markoff
Macintosh
MacPaint
Microsoft
Museums
NeXT
Programming
Programming Language
Science Fiction
Semiconductors
Silicon Valley
software
Source Code
SRI
Steve Jobs
technology
Web History
William Shockley
Xerox PARC 




Categories


 
						Behind the Scenes 
					
(28)


 
						CHM Live 
					
(31)


 
						Curatorial Insight 
					
(67)


 
						Education 
					
(10)


 
						Exponential Center 
					
(24)


 
						From the CEO 
					
(2)


 
						From the Collection 
					
(52)


View More


Archives
 

                    May 2018                    (1)




                    April 2018                    (5)




                    March 2018                    (5)




                    February 2018                    (5)




                    January 2018                    (4)




                    December 2017                    (4)




                    November 2017                    (5)



View More


Bloggers









                                Chris Garcia                            










                                Dag Spicer                            










                                Marc Weber                            










                                David Laws                            










                                Len Shustek                            










                                CHM Editorial Team                            










                                Jennifer De La Cruz                            










                                David Brock                            



All Bloggers





 Home

The APL Programming Language Source Code



 Len Shustek                    

  October 10, 2012
 From the Collection
 13

Software Gems: The Computer History Museum Historical Source Code Series
Ken Iverson at Harvard University
Thousands of programming languages were invented in the first 50 years of the age of computing. Many of them were similar, and many followed a traditional, evolutionary path from their predecessors.
But some revolutionary languages had a slant that differentiated them from their more general-purpose brethren. LISP was for list processing. SNOBOL was for string manipulation. SIMSCRIPT was for simulation. And APL was for mathematics, with an emphasis on array processing.
What eventually became APL was first invented by Harvard professor Kenneth E. Iverson in 1957 as a mathematical notation, not as a computer programming language. Although other matrix-oriented symbol systems existed, including the concise tensor notation invented by Einstein, they were oriented more towards mathematical analysis and less towards synthesis of algorithms. Iverson, who was a student of Howard Aiken’s, taught what became known as “Iverson Notation” to his Harvard students to explain algorithms.
Iverson was hired by IBM in 1960 to work with Adin Falkoff and others on his notation. In his now famous 1962 book “A Programming Language” [1], he says the notation is for the description of “procedures…called algorithms or programs”, and that it is a language because it “exhibits considerable syntactic structure”. But at that point it was just a notation for people to read, not a language for programming computers. The book gives many examples of its use both as a descriptive tool (such as for documenting the definition of computer instruction sets) and as a means for expressing general algorithms (such as for sorting and searching). Anticipating resistance to something so novel, he says in the preface, “It is the central thesis of this book that the descriptive and analytical power of an adequate programming language amply repays the considerable effort required for its mastery.” Perhaps he was warning that mastering the language wasn’t trivial. Perhaps he was also signaling that, in his view, other notational languages were less than “adequate”.
The team, of course, soon saw that the notation could be turned into a language for programming computers. That language, which was called APL starting in 1966, emphasized array manipulation and used unconventional symbols. It was like no other computer program language that had been invented.
APL became popular when IBM introduced “APL\360” for their System/360 mainframe computer. Unlike most other languages at the time, APL\360 was also a complete interactive programming environment. The programmer, sitting at an electromechanical typewriter linked to a timeshared computer, could type APL statements and get an immediate response. Programs could be defined, debugged, run, and saved on a computer that was simultaneously being used by dozens of other people.
Written entirely in 360 assembly language, this version of APL took control of the whole machine. It implemented a complete timesharing operating system in addition to a high-level language.
With the permission of IBM, the Computer History Museum is pleased to make available the source code to the 1969-1972 “XM6” version of APL for the System/360 for non-commercial use.
The text file contains 37,567 lines, which includes code, macros, and global definitions. The 90 individual files are separated by ‘./ ADD” commands. To access this material, you must agree to the terms of the license displayed here, which permits only non-commercial use and does not give you the right to license it to third parties by posting copies elsewhere on the web.
Download APL360 Source Code
Jürgen Winkelmann at ETH Zürich has done an amazing job of turning this source code into a runnable system. For more information, see http://wotho.ethz.ch/mvt4apl-2.00/.

Additional Material

Creating the APL Programming Language
A Taste of APL
How APL was Implemented
Applications of APL
APL Praise and Criticism
A Short Biography of Ken Iverson
Acknowledgements
Bibliography


Creating the APL Programming Language
Iverson’s book “A Programming Language” [1] uses a graphical notation that would have been difficult to directly use as a programming language for computers. He considered it an extension of matrix algebra, and used common mathematical typographic conventions like subscripts, superscripts, and distinctions based on the weight or font of characters. Here, for example, is a program for sorting numbers:

To linearize the notation for use as a computer programming language typed at a keyboard, the APL implementers certainly had to give up the use of labeled arrows for control transfers. But one feature that they were able to retain, to some extent, was the use of special symbols for primitive functions, as illustrated in this program that creates Huffman codes:


APL uses symbols that are closer to standard mathematics than programming. For example, the symbol for division is ÷, not /. To support the unconventional symbols, APL\360 used a custom-designed keyboard with special symbols in the upper case.

APL\360 used a custom-designed keyboard
Even so, there were more special characters than could fit on the keyboard, so some were typed by overstriking two characters. For example, the “grade up” character ⍋, a primitive operator used for sorting, was created by typing ∆ (shift H), then backspace, then ∣ (shift M). There was no room left for both upper- and lower-case letters, so APL supported only capital letters.
For printing programs, Iverson and Falkoff got IBM to design a special type ball for their 1050 and 2741 terminals, which used the IBM Selectric typewriter mechanism.


Now programs could be both typed in and printed. Here, for example, is the printed version a program from the APL Language manual [2] that computes the mathematical determinant of a matrix:


A Taste of APL
APL is a concise high-level programming language that differs from most others developed in the 1960s in several respects:
Order of evaluation: Expressions in APL are evaluated right-to-left, and there is no hierarchy of function precedence. For example, typing the expression
2×4+3
causes the computer to immediately type the resulting value
14
The value is not, as in many other languages that have operator precedence, 11. Of course, parentheses can be used to group a subexpression to change the evaluation order. The general rule is that the right argument of any function is the value of the expression to its right.
Automatic creation of vectors and arrays: A higher-dimensional structure is automatically created by evaluating an expression that returns it, and scalars can be freely mixed. For example,
A ← 2 + 1 2 3
creates the vector “1 2 3”, add the scalar 2 to it, and creates the variable A to hold the vector whose value is
3 4 5
Variables are never declared; they are created automatically and assume the size and shape of whatever expression is assigned to them.
A plethora of primitives: APL has a rich set of built-in functions (and “operators” that are applied to functions to yield different functions) that operate on scalar, vectors, arrays, even higher-dimensional objects, and combinations of them. For example, the expression to sum the numbers in the vector “A” created above is simply
+/A
where / is the “reduction” operator that causes the function to the left to be applied successively to all the elements of the operand to the right. The expression to compute the average of the numbers in A also uses the primitive function ρ to determine how many elements there are in A:
(+/A) ÷ ρA
Here are some tables from the 1970 “APL\360 User’s Manual” [3] that give a flavor of the power and sophistication of the built-in APL functions and operators. (Click on the images for larger versions.)

 



APL encourages you to think differently about programming, and to use temporary high-dimensional data structures as intermediate values that are then reduced using the powerful primitives. A famous example is the following short but complete program to compute all the prime numbers up to R.
(~T∊T∘.×T)/T←1↓⍳R
Here is how this expression is evaluated:
 




subexpression


meaning


value if R is 6




⍳R


Generate a vector of numbers from 1 to R.


 1 2 3 4 5 6




T←1↓


Drop the first element of the vector and assign the rest to the temporary vector T.


2 3 4 5 6




T∘.×T


Create the multiplication outer product: a table that holds the result of multiplying each element of T by each element of T.






4


6


8


10


12




6


9


12


15


18




8


12


16


20


24




10


15


20


25


30




12


18


24


30


36









T∊


Use the “set membership” operator to find which elements of T are in the table.


0 0 1 0 1




~


Negate the result to identify which elements of T are not in the table.  These are the integers which do not have any multiples in the table.


1 1 0 1 0




( )/T


Select the elements of T which we have identified.    These are all the primes less than R.


2 3 5




 
Note that there are no loops in this program. The power of APL expressions means that conditional branches and loops are required far less often than in more traditional programming languages.
APL operators can be used in easy ways for all sorts of computations that would usually require loops. For example, an expression that computes the number of elements of the vector X that are greater than 100 is
 +/X>100
It works because X>100 returns a bit vector of 0’s and 1’s showing which elements of X are greater than 100, and +/ adds up all the bits in that vector.
But conditional execution and loops are, of course, sometimes needed. In the light of later developments in structured programming, APL’s only primitive for control transfer, the “GO TO LINE x” statement →, is particularly weak. Here is an example of a function that computes the greatest common divisor of its two arguments. The last statement creates a loop by branching to the beginning. In line 2, conditional transfer of control to line 0 causes the function to exit and return the value last assigned to G.

To learn more about the 1960’s APL language, see the “APL Language” reference manual [2] and Paul Berry’s 1969 “APL\360 Primer” [4].
The language has of course evolved over the years, and more recent versions include control structures such as IF-THEN-ELSE.

How APL was Implemented
The first computer implementation of APL notation was a batch-oriented language interpreter written in FORTRAN in 1965 for the IBM 7090 mainframe computer, by Larry Breed at the IBM Research Center in Yorktown Heights NY and Philip Abrams, then a graduate student at Stanford University.
The first interactive version was written soon after for the 7093 (an experimental 7090 with virtual memory) by Larry Breed and Roger Moore. It ran under the TSM timesharing system and was whimsically called “IVSYS”, which rhymes with “IBSYS”, the name for the standard 7090 operating system. In a 2012 email Breed says,
IVSYS provided login, logout, immediate execution and function definition; it provided workspaces, both active and stored. Implementation of these was rudimentary; mostly we used whatever the TSM project offered us for login/logout/saving files. We had only a few weeks to use the 7093 before it was decommissioned and Roger and I started planning for a standalone system on System/360. In those weeks, Ken and his group saw for the first time what executable APL would be like.
Another implementation of a subset of the language was done in 1967 for the IBM 1130 minicomputer.
The first implementation of APL to get widespread use outside of IBM was for the IBM System/360. Called “APL\360”, it went into service first within IBM in November 1966. (The notation “APL\360″, since the backslash was the APL “expansion” operator, also had a hidden meaning: “APL expands the 360″).
Breed says of the time just before,
This period, early 1966, was the transitional time from Iverson Notation to APL. (Indeed, Adin [Falkoff] came up with “APL” in Spring ’66.) Refinement and extension of the language and the environment continued for many years. There was next to no code added to make a commercial version, just paperwork.
By August 1968 APL\360 was available to IBM customers as an unsupported (“Type III”) program in IBM’s “Contributed Program Library” [5]. The principal implementers were Larry Breed, Dick Lathwell, and Roger Moore; others who had contributed were Adin Falkoff and Luther Woodrum.
Early APL developers, from left to right: Dick Lathwell, Ken Iverson, Roger Moore, Adin Falkoff, Phil Abrams, Larry Breed. The photo was taken about 1983.
Because of the dynamic nature of APL variables, APL\360 was implemented as an interpreter, not as a compiler that generated machine code.  Programs were stored in an internal form called a “codestring” that directly corresponded to what the user had typed. The interpreter would then examine the codestring as the program executed, and dynamically allocate and reconfigure variables as expressions were evaluated.
The first versions of APL\360 took control of the entire machine. It was thus a combination operating system, file system, timesharing monitor, command interpreter, and programming language. Given the limited main memory, user workspaces were swapped out to drum or disk as needed. Performance was impressive, which Larry Breed attributes, in his clear and succinct description of the implementation [6], to the ability to tailor the operating system to the requirements of the language.
APL\360 was a conversational language that provided fast response and efficient execution for as many as 50 simultaneous users. Each user had an “active workspace” that held programs, variables, and the state of suspended program execution. System commands like “)LOAD”, “)SAVE”, and “)COPY” maintained the user’s library of stored workspaces. Other system commands controlled language features; for example, with “)ORIGIN” the programmer could control whether vectors and arrays are numbered starting with 0 or 1.
APL was the first introduction to interactive timesharing for many in the generation of programmers who had suffered through batch programming with punched cards.
Applications of APL
Even before it was a computer programming language, Iverson Notation was useful as a language for documenting algorithms for people. The classic example is the formal definition of the instruction-set architecture of the new IBM System/360 computer, which was published in an article in the IBM Systems Journal by Adin Falkoff, Ken Iverson, and Ed Sussenguth in 1965 [7].
The description, which is formal rather than verbal, is accomplished by a set of programs, interacting through common variables, used in conjunction with auxiliary tables… Although the formal description is complete and self-contained, text is provided as an aid to initial study.
But the text provided in the paper is much more than that. It is a line-by-line explanation of the formal description, which means that it is also a demonstration and explanation of APL’s descriptive power.
The notation used the graphical style for control transfers that was in Iverson’s book. Here, for example, is the description of a memory access operation. (Click it to enlarge.)

It was the transition of APL from a notation for publication into an interactive computer programming language that made it flourish. When the APL\360 implementation was available, IBM and others stimulated use by producing diverse applications such as these:

Starmap: A set of APL functions to calculate and plot the positions of the stars and planets. [8] [9] It was written in 1973 by Paul Berry of IBM and John Thorstensen, then an astronomy student at Bryn Mawr college, now Professor of Physics and Astronomy at Dartmouth College. It uses classical solutions to Kepler’s equations for a particular date and time and a series of rotations of coordinates to show where the planets and the stars would appear in the bowl of the sky.
IBGS: Interactive Business Game Simulation: “A general computer management simulation involving decision making and planning in the functional areas of production, marketing and finance.”
Zeros and Integrals in APL: “Using both classical methods such as Newton’s and Muller’s and recently developed methods such as Jenkins and Traub’s, it finds reals zeros of a real function, real and complex zeros of a polynomial with real of complex coefficients, and complex zeros of a complex function.”
Graphpak – Interactive Graphics Package for APL\360: “…capabilities which range from graphics interface support at the lowest level to several application areas at higher levels…A plotting component…linear or logarithmic…curve-fitting… A descriptive geometry component allows definition, scaling, magnification, translation, rotation, and projected display of three-dimensional objects.”
Graphs and Histograms in APL: “produces curves and barcharts at a typewriter terminal”.
APL Coordinate Geometry System: “solves coordinate geometry problems interactively at a terminal…for use by surveyors, civil engineers, urban planners…”
APL/PDTS – Programming Development Tracking System: “…to assist managers and planners in monitoring performance against plan on programming development projects.”
MINIPERT: “A Critical Path Method (CPM) system for Project Management”
APL Econometric Planning Language: “The practicing economist, business forecaster or teacher is provided with easy-to-use tools for interactive model building and model solving.”
APL Financial Planning System: “lets the financial analyst and planner design reports, specify calculation statements, enter and change data, and obtain printed reports with immediate turnaround.”
APL Text Editor and Composer: “This program is designed to process text interactively at a terminal…Functions are included for entering, revising, composing, printing, and storing text…for use by secretaries, scientists, engineers, administrators or any others who produce papers, letters, reports or specifications.”

Many of these applications emphasized interactivity, which provided a huge productivity increase compared to the batch-job processing more typical at the time. In addition, APL allowed applications to be developed much more quickly. In a 2012 email, Larry Breed noted,
Across all fields, the speed at which APL programs can be written makes it valuable for modeling and prototyping . … One example: Around 1973, Continental Can needed an inventory system for its 21 manufacturing plants. Their team of FORTRAN programmers had worked for a year, with no success in sight. One STSC salesman, in one weekend, built a usable working model in APL Plus.
The areas in which APL had the greatest penetration were in scientific, actuarial, statistical, and financial applications. For details about the progression of APL in its first 25 years, see the special 1991 issue of the IBM System Journal [10] with 12 papers and one essay on the subject.
APL Praise and Criticism
APL was not originally designed as a programming language.  As Iverson said,
The initial motive for developing APL was to provide a tool for writing and teaching. Although APL has been exploited mostly in commercial programming, I continue to believe that its most important use remains to be exploited: as a simple, precise, executable notation for the teaching of a wide range of subjects. [11]
With so many terse and unusual symbols, APL computer programs, like the mathematical notation that inspired it, has a conciseness and elegance many find appealing.  APL attracts fanatic adherents.  Alan Perlis (the first recipient of the ACM’s Turing Award, in 1966) was one:
The sweep of the eye across a single sentence can expose an intricate, ingenious and beautiful interplay of operation and control that in other programming languages is observable only in several pages of text. One begins to appreciate the emergence and significance of style. [12]
Many find the freedom of expression in APL liberating.
I used to describe [Pascal] as a ‘fascist programming language’, because it is dictatorially rigid. …If Pascal is fascist, APL is anarchist. [13]
But APL programs are often cryptic and hard to decode.  Some have joked that it is a “write-only language” because even the author of a program might have trouble understanding it later.  It inspires programming trickery.  The challenge of writing an APL “one-liner” to implement a complete complex algorithm is hard to resist.  Here, for example, are two different APL one-liners that implement versions of John Conway’s  “Game of Life“:
life←{↑1 ω∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂ω}
 
Not for the faint-hearted, clearly. Dutch computer scientist Edsger Dijkstra said,
APL is a mistake, carried through to perfection. It is the language of the future for the programming techniques of the past: it creates a new generation of coding bums. [14]
But fans of APL would say that cryptic APL coding is a bad programming style that can be an affliction with any language. APL provides a richer palette for expressing algorithms, the argument goes, so you can solve harder problems faster and with less irrelevant syntactic clutter.
Whatever your view, APL and the languages it inspired, such as APL2 and J, are still an active part of the diverse programming language universe.
A Short Biography of Ken Iverson
Kenneth Eugene Iverson was born on December 17, 1920 on a farm near Camrose, Alberta, Canada. He was educated in rural one-room schools until the end of 9th grade, when he dropped out of school because it was the height of the Depression and there was work to do on the family farm. He later said the only purpose of continuing his schooling would have been to become a schoolteacher, and that was a profession he decidedly did not want. During the long winter months he studied calculus on his own.
He was drafted in 1942, and during his service he took enough correspondence courses to almost complete high school. After the military service he earned a B.A. in both mathematics and physics from Queen’s University in Kingston Ontario, and then an M.A. in physics from Harvard University. In 1954 he completed a PhD under computer pioneer Howard Aiken, with a thesis titled “Machine Solutions of Linear Differential Equations: Applications to a Dynamic Economic Model”.
After completing his doctorate, Iverson joined the Harvard faculty to teach in Aiken’s new automatic data processing program. He was there for one year as an Instructor, and for five years as an Assistant Professor. He became increasingly frustrated with the inadequacy of conventional mathematical notation for expressing algorithms, so he began to invent his own.
In 1960 Iverson joined the new IBM Research Center in Yorktown Heights, New York, on the advice of Frederick Brooks, who had been one of his teaching fellows at Harvard and was now at IBM. The two collaborated on the continuing development of the new notation. In 1962 Ken published the now-classic book “A Programming Language” [1], the title of which gave the name APL to the notation which had up until then been informally called “Iverson’s notation”.
Iverson continued to work on the development of APL throughout his tenure at IBM. In 1980 he left IBM and returned to Canada to work for I.P. Sharp Associates, which had established an APL-based timesharing service.
In 1987 he “retired from paid employment” and turned his full attention to the development of a more modern dialect of APL. APL was successfully being used for commercial purposes, but Iverson wanted to develop a new simple executable notation more suitable for teaching, which would be available at low cost. The first implementation of this language, called J, was announced at the APL90 Users’ Conference.
Iverson’s ability to create such languages came from his “sheer enjoyment of language and words,” recalls his daughter Janet Cramer. “He read dictionaries like people read novels.” Iverson thought it was important that language, both English and mathematics, communicate clearly and concisely.
With collaborators that included his son Eric, Iverson continued to work on the development of J, and he continued to publish prolifically. On Saturday, October 16, 2004 he suffered a stroke –while working on a J tutorial — and died three days later on October 19, at the age of 83.
There are many stories about Ken Iverson. Here are a few:
Ken didn’t get tenure at Harvard. He did his five years as an assistant professor and the Faculty decided not to put him up for promotion. I asked him what went wrong and he said, “Well, the Dean called me in and said, ‘the trouble is, you haven’t published anything but the one little book’”.
The one little book later got [him] the Turing Award. I think that is a comment on the conventional mindset of promotion procedures rather than a comment on Ken; it’s a comment on academic procedure and on Harvard.Fred Brooks, A Celebration of Kenneth Iverson, 2004-11-30
In an early talk Ken was explaining the advantages of tolerant comparison. A member of the audience asked incredulously, “Surely you don’t mean that when A=B and B=C, A may not equal C?” Without skipping a beat, Ken replied, “Any carpenter knows that!” and went on to the next question.
 Paul Berry
In a social conversation with Ken, I said, “You know, Ken, you are my favorite language designer and Don Knuth is my favorite programmer.” And Ken said immediately, “What’s wrong with my programming?” Joey Tuttle, A Celebration of Kenneth Iverson, 2004-11-30
In 1973 or 1974 Ken and I gave a talk at Kodak in Rochester to a group of 40 to 50 programmers who were required to work in PL/I. In the question period a senior staff member said, “If I understand what you people are saying, you are suggesting that we should adopt a new way of thinking.”
And Ken jumped up out of his chair and said, “Yes! That’s exactly what I am saying!” Joey Tuttle, A Celebration of Kenneth Iverson, 2004-11-30
Acknowledgements
Thanks to Michael Karasick, Yvonne Perkins, Steve Selbst, and Ken Edwards of IBM for ending my ten-year odyssey to get permission to release the APL source code. Thanks to Curtis Jones, Larry Breed, Paul Berry, and Roy Sykes for their comments on an early draft of this article. Len Shustek
Bibliography

[1] K. E. Iverson, A Programming Language, John Wiley and Sons, Inc., 1962.
[2] IBM, “APL Language,” March 1975.
[3] IBM, “APL\360 User’s Manual,” March 1970.
[4] IBM, Paul Berry, “APL\360 Primer – Student Text,” 1969.
[5] L. M. Breed and R. H. Lathwell, “APL\360,” 1968.
[6] L. M. Breed and R. H. Lathwell, “The Implementation of APL\360,” in ACM Symposium on Experimental Systems for Interactive Applied Mathematics, 1967.
[7] A. D. Falkoff, K. E. Iverson and E. H. Sussenguth, “A Formal Description of SYSTEM/360,” IBM Systems Journal, vol. 3, no. 3, pp. 198-261, 1964.
[8] P. C. Berry and J. R. Thorstensen, “Starmap,” 1978.
[9] P. C. Berry and J. R. Thorstensen, “Starmap,” IBM Systems Development Division, 1975.
[10] IBM Systems Journal, vol. 30, no. 4, 1991.
[11] K. E. Iverson, “A Personal View of APL,” IBM Systems Journal, vol. 30, no. 4, 1991.
[12] A. J. Perlis, “In Praise of APL: A Language for Lyrical Programming,” SIAM News, June 1977.
[13] B. McCormick, “A Programming Language,” 2000,2002.
[14] E. W. Dijkstra, “How Do We Tell Truths That Might Hurt?”,” SIGPLAN Notices, vol. 17, no. 5, May 1982.
[15] A. D. Falkoff and K. E. Iverson, “The Design of APL,” IBM Journal of Research and Development, vol. 17, no. 4, 1973.
[16] A. D. Falkoff and K. E. Iversion, “The Evolution of APL,” SIGPLAN Notices, vol. 13, no. 8, pp. 45-57, August 1978.
[17] L. Breed, “How We Got to APL\1130,” 10 May 2004.
[18] ACM, “Proceedings of the APL’69 Conference on APL,” SUNY Binghamton, NY, 1969.
[19]“The Origins of APL – 1974“; a wonderful interview with the original developers of APL.

Historical Source Code Releases @CHM

MacPaint and QuickDraw Source Code, July 18, 2010
APL Programming Language Source Code, October 10, 2012
Adobe Photoshop Source Code, February 13, 2013
Apple II DOS Source Code, November 12, 2013
Microsoft MS-DOS Early Source Code, March 25, 2014
Microsoft Word for Windows Version 1.1a Source Code, March 25, 2014
Early Digital Research CP/M Source Code, October 1, 2014
Xerox Alto Source Code, October 21, 2014
Electronic Arts DeluxePaint Early Source Code, July 22, 2015




RELATED ARTICLES








The Shocking Truth Behind Arnold Nordsieck’s Differential Analyzer
January 18, 2018











In the Holiday Spirit: Festive Music by Computer!
December 21, 2017











Into the Archives: A Look Back with “Robotic Artist” Harold Cohen
October 20, 2017











Seymour Cray: The Man Who Brought Style to Supercomputers
September 14, 2017






ABOUT LEN SHUSTEK







Len Shustek is chairman of the board of trustees of the Computer History Museum. In 1979, he co-founded Nestar Systems, an early developer of networks for personal computers. In 1986, he co-founded Network General, a manufacturer of network analysis tools including The Sniffer™. The company became Network Associates after merging with McAfee Associates and PGP.  ...
More










clathwell



Dear Len,
What a great way to honour the 50th anniversary of the publication of A Programming Language.  There is a subtle wave of appreciation for your leadership here quietly sweeping the planet.






bobc4012



APL was a great language. It was used internally by IBM. Unfortunately, IBM management never had the foresight to push it as a mainstream language. Just like so many other things. If IBM management hadn’t been so fixated on PL/I and MVS (sold the big iron) and looked at VM and APL plus their own internal version of PL/I (the internal was more powerful than C), Unix and C would have been another “interesting” OS and language.






http://myindigolives.wordpress.com/                Ellie Kesselman



Bob,
Yes, thank you! Here’s why: While at IBM, I recall MVS and Fortran 77. I used SAS for modeling* accessed via my development login to VM. I couldn’t recall the context for using APL though. Now I remember; it was just as you described! 
We only coded in APL internally, within GPD (Tucson and of course, South San Jose), for DASD performance and competitive analysis, never for anything beyond IBM. I have pleasant memories of APL. I definitely commented my code. There were others who took pride in having as few blank spaces as possible, a solid, monolithic block of symbols!
Thank you so much, Computer History Museum, for noting the 50th anniversary of the publication of A Programming Language. It brings back many sweet memories. I didn’t know it at the time, but the happiest years of my life were threaded with lines of APL code.
* We used Minitab, then SAS at IBM. I had never even heard of SPSS back then!








TaliesinSoft



Not to be forgotten is that following IBM’s release of APL a number of other releases occurred, both from time sharing services and from computer companies. As for myself I headed the APL\700 project at Burroughs for about eight years. I will, with pride, take responsibility for a number of additions to the language, additions which were included in the adopted standard for APL. Currently I am an avid user of Dyalog APL which is actively maintained by; a company in England.






ka1axy



When I was an engineer in the communications and networking group at Data General, I wrote firmware to allow our D200 video terminal to perform the gymnastics necessary to support a DG version of APL. This meant adding a firmware routine to detect and display overstruck characters, by looking at the current character being displayed at the cursor position and using it, with the newly input character code to search a data structure for the character code of the composite overstruck character. I was pretty proud of that code. 
As far as I know, Data General’s APL went pretty much nowhere.








chuckwegrzyn



I was lucky to be a student in 1967 working at SRA (part of IBM). I got to play around with APL/360 as it was being developed. In fact IBM held introduction to APL classes!
I got to meet most of the people in your picture, as well as many others working on APL for the 1130 series of computers. It was a fun time!






davecortesi



Thanks for making the APL\360 code available. For anyone browsing it, I call your attention to the SVRAPE macro at line and the constant YYRAPE at line 884, defined as Request Anomalous Protection Exception. The actual implementation of the macro is at line 4492. What it does is to execute the single instruction following the macro in Supervisor mode, so that the programmer could, presumably judiciously and with great care, bypass Storage Protection to patch memory that didn’t belong to APL. For example at line 2872 it is used to move two bytes to location 2. At line 12416 it is storing a word into protected memory owned by the OS.
The DOS/360 version of the APL system, used in the lower-end computers (363/30, 360/40), APL basically took over the system from the OS and ran the hardware on its own. In the larger machines under MVS, it behaved itself but still occasionally RAPED the OS.






lexx



I see the programs I wrote for grade and indexing are in there, from lines 14,458 to 16,184.  I remember in 1966 I was working on
sorting, and I had collected data from running
a program that did all intercylinder seeks on
a disk 50 times, and I wanted to sort them by
absolute value.
Since I had already written indexing, I put in a check for my user ID and sort became ibeam something. Then I used it to sort the numbers.  It turned out that it was more useful return the indices of the elements in
order, so I computed them.
This went on for 3 or 4 weeks in 1966, and then I got a call from Adin Falkoff, asking
me to change the user id check so others could play with it too.
Then Ken Iverson got all excited when he found out that the grade of a permutation was
the inverse of a permutation, and that’s how grade got in the language.
The algorithm uses a partial order tree.
The partial order tree is similar to a heap tree, but it does half as many compares.
I first used the partial order tree in
phase 1 of the 7070 hypertape sort, in 1962
and released in 1963.  
Can you get IBM to make the source for the 7070 sort available?  That would be interesting.
The grade program is only 225 lines long.
It worked correctly from the first install forever.
By contrast, the 7070 phase sort was 8,000 lines long, and took 18 months to write.
But it was released in July on 1963, and had
no bugs forever.  By contrast, phase 2 had
200 APARs in the first 60 days after release.
I think it is important for a program to have no bugs forever.  You never know when someone’s life may depend on it.
After I wrote APL indexing, with 7 dimensional arrays, after an initial checkout period, it also had no bugs forever,
except for one thing that was actually a design error.  When checking arrays for compatible dimensions, it used an exclusive or of the two dimension vectors, shifted.
But that had the unintended consequence that
a 2 x 4 array looked as if it had the same dimensions as a 4 x 2 array.
This did not cause any serious problems, but it did allow user errors to slip by, which eventually did happen.
When the VM microcode APL was done, all or most all of the operations ran 10 to 25 x faster, except for grade, indexing, and up down arrows, which I also wrote.  These operations did not run any faster.
When I was integrating the grade into the APL
system, I had to change OP control.  Op control looks at the operation, its inputs and outputs, and computes the type of the result.
There was no logic in Op control to handle
grade, so I ended up rewriting Op control to add the grade logic. It was then 4 pages long, instead of 8 pages long, and the whole APL interpreter ran 2.5 times faster than before.  No one ever noticed, but I did.
All of my programs ran 2.5 x faster.
Luther Woodrum






brentl



Congratulations. A beautiful exhibit. As an assembler programmer who started in 1967, and a sometime APL user, I found this nostalgic, and the source code surprisingly strange! 
By the way, the source code contains two copies of APLSUPC. Fortunately, they are identical.






Zinc



Thanks much for your efforts making this available.  In the early ’70s I attended a JC in Southern California that had a System/360 with about 80 APL terminals for student use.  It was my first experience with a computer and APL was the first language I learned. I’ve since learned many others and am still a professional software developer. In many ways, language power has never since attained that which that original APL provided.  I also wrote my own APL interpreter on Windows for my own use as a quick calculator and so I can continue to enjoy its merits.
 At the JC a bug was discovered in the interpreter in the laminate operator that allowed you to create a matrix with negative dimensions that could be used to access any part of the system, including protected areas and password files, so it was also an initial exposure to “hacking”.  Fond memories.






lobachevsky



What I find amazing is that like operating a fleet of steam locomotives, today’s mainstream languages like Java are incredibly labour-intensive.  APL was quite the opposite.  No wonder work is going to India.  (I suppose you can still find steam locomotives there too)






Dick Conklin



I also worked on APL during the 1970s, first the mainframe version, then the desktop IBM 5100 (with the built-in postcard-size screen). Was also active in the APL Users Group. My next project was the IBM PC, including the APL interpreter created by IBM’s Madrid Scientific Center. I tried to get the IBM Palo Alto folks to consider a radical idea — merging APL with a spreadsheet so that the cell formulas could be written in APL. They thought I was nuts!






PeterCapek



The 360 implementation of APL introduced the notion of a workspace, for the first time, as far as I know.  While APL-the-language is a wonderful tool, it always seemed to me beyond that that it was, especially for its time an excellent implementation (reliable, fast, responsive, useable, …) and I think that contributed as much to its (too) modest success.







/* <![CDATA[ */
    var disqus_url = 'http://www.computerhistory.org/atchm/the-apl-programming-language-source-code/';
    var disqus_identifier = '1032 http://www.computerhistory.org/atchm/?p=1032';
    var disqus_container_id = 'disqus_thread';
    var disqus_domain = 'disqus.com';
    var disqus_shortname = 'atchm';
    var disqus_title = "The APL Programming Language Source Code";
        var disqus_config = function () {
        var config = this; // Access to the config object
        config.language = '';

        /*
           All currently supported events:
            * preData — fires just before we request for initial data
            * preInit - fires after we get initial data but before we load any dependencies
            * onInit  - fires when all dependencies are resolved but before dtpl template is rendered
            * afterRender - fires when template is rendered but before we show it
            * onReady - everything is done
         */

        config.callbacks.preData.push(function() {
            // clear out the container (its filled for SEO/legacy purposes)
            document.getElementById(disqus_container_id).innerHTML = '';
        });
                    };
/* ]]> */


/* <![CDATA[ */
    var DsqLocal = {
        'trackbacks': [
        ],
        'trackback_url': "http:\/\/www.computerhistory.org\/atchm\/the-apl-programming-language-source-code\/trackback\/"    };
/* ]]> */


/* <![CDATA[ */
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.' + 'disqus.com' + '/embed.js?pname=wordpress&pver=2.74';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
/* ]]> */






                        Copyright © var currentTime = new Date(); document.write(currentTime.getFullYear());  Computer History Museum
                    

TERMS OF USE  
                        PRIVACY  
                        SITE MAP





            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
            
            ga('create', 'UA-604998-1', 'computerhistory.org');
            ga('send', 'pageview');
        

    // <![CDATA[
        var disqus_shortname = 'atchm';
        (function () {
            var nodes = document.getElementsByTagName('span');
            for (var i = 0, url; i < nodes.length; i++) {
                if (nodes[i].className.indexOf('dsq-postid') != -1) {
                    nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('rel'));
                    url = nodes[i].parentNode.href.split('#', 1);
                    if (url.length == 1) url = url[0];
                    else url = url[1]
                    nodes[i].parentNode.href = url + '#disqus_thread';
                }
            }
            var s = document.createElement('script'); s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + 'disqus.com/forums/' + disqus_shortname + '/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    //]]>
    




